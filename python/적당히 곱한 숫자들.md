* 적당히 곱한 숫자들 (Day 1+2 - Data Structure)

숫자가  a1 , a2 ,…, an 까지 소수(prime number)  n 개가 주어졌을 때, 1에 각 숫자를 여러번 적당히 곱하여 다양한 수를 만들 수 있습니다. 예를 들어  n 개의 숫자가 2, 3, 5가 있다면 만들 수 있는 다양한 수는 아래와 같습니다.

1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,…
이 때 만들 수있는 수 중에서  k 번째로 작은 수를 구하는 프로그램을 작성하세요.

현재 민철이가 구현한 방식은 아래와 같습니다.

i=1 
숫자  i 에 대해서,  i 가  a1 , a2 ,…, an 만으로 소인수분해가 되는지 확인한다. 그렇지 않다면, 이들을 적당히 곱해 만들 수 있는 수가 아니므로 2번은 생략한다.
리스트에  i 를 추가한다. 리스트의 크기가  k 가 된다면, 마지막에 추가된 숫자를 출력하고 프로그램을 종료한다.
i 가 아닌  i+1 에 대해서 다시 1부터 수행한다.
숫자가 2, 3, 5이고 7번째 숫자를 구하는 예제를 보면,

1
2 = 2
3 = 3
4 = 2x2
5 = 5
6 = 2x3
7 = 안 됨
8 = 2x2x2 : 7번째이므로 출력하고 종료한다.
하지만 이 방식(시간복잡도:  O(Nf(N)) ,  N 은 답에 해당하는  k 번째 숫자,  f(N) 은 소인수분해 횟수)은 너무나도 느리기 때문에, 좀 더 효율적인 알고리즘을 필요로 합니다. 좀 더 효율적인 알고리즘으로 바꾸어 구현하세요. (Hint:  O(nklog(nk)) )

입력 형식
입력의 첫 줄에 테스트 케이스의 숫자  T 가 주어진다.
그 후,  T 개의 테스트 케이스마다 입력은 아래와 같다.
첫 줄에는 숫자  k(≤50,000) 와  n(≤20) 이 띄어쓰기로 구분된 채 주어진다.
둘째 줄에는  n 개의 소수가 띄어쓰기로 구분된 채 주어진다. 각 소수는 500을 넘지 않는다.
출력 형식
각 테스트 케이스에 대해  n 개의 소수를 곱하여 만들 수 있는 수 중에  k 번째로 작은 수를 출력한다.
입력 예시
4
10 2
2 5
10 2
2 7
30 3
29 43 109
5 5
2 2 3 5 5

출력 예시
32
49
9991921
5

예제 1 설명
1에 2와 5를 적당히 곱해서 만들 수 있는 숫자는
1,2,4,5,8,10,16,20,25,32,… 등이 있다. 이중에서 10번째로 작은 수는 512이다.

예제 2 설명
1에 2와 7을 적당히 곱해서 만들 수 있는 숫자는
1,2,4,7,8,14,16,28,32,49,… 등이 있다. 이중에서 10번째로 작은 수는 49이다.

예제 3 설명
9991921 = 29 x 29 x 109 x 109

예제 4 설명
중복을 제외하고, 2, 3, 5를 적당히 곱해서 만들 수 있는 숫자는 1,2,3,4,5,... 등이 있다. 이중에서 5번째로 작은 수는 5이다.

HINT
자료구조는 우선순위 큐를 사용합니다. 우선순위 큐는 우선순위가 낮은 쪽이 우선 나오게 되는 Min Queue를 생각할 수 있습니다. 우선순위 큐에 어떠한 숫자들을 넣어야 할지 생각해보세요.
보통 리스트를 써서 중복되는 숫자를 체크할 때 if에 in을 쓰게(ex: if number in List) 되는데, list는 중복된 값이 들어올 수 있는 특성 때문에 선형 탐색을 하게 됩니다. list 대신에 파이썬의 중복된 값을 무시하는 set을 이용한다면(if number in Set) 훨씬 빠르게 할 수 있습니다.
입력에서 숫자는 중복될 수 있습니다. 예제 4를 참고하세요.

---
기본 
```python
#기초 입력
T = int(input())
for _ in range(T):
	k,n = map(int,input().split())
	numbers = list(map(int,input().split()))
	possible = [] #가능한 숫자를 넣는 리스트
	#주어진 숫자들로 소인수분해하기
	i=1
	while len(possible) < k: #k번째 숫자가 들어오면 멈춤
		factor = i #소인수분해 확인을 위한 i와 같은 임시의 값
		for x in numbers: #숫자들로 소인수분해
			while factor % x == 0:
				factor //= x
		if factor == 1: #소인수분해가 잘되면 factor=1
			possible.append(i)
		i += 1
	#k번째 숫자를 출력
	print(possible[-1])
```  

by. korea1782
```python
import heapq
import sys
T = int(sys.stdin.readline())
for _ in range(T):
    k, n = map(int, sys.stdin.readline().split())
    numbers = list(set(map(int, sys.stdin.readline().split())))
    numlist = numbers[:]
    for i in range(k-1):
        temp = heapq.heappop(numbers)
        for j in numlist:
            heapq.heappush(numbers, temp*j)
            if temp%j == 0:
                break
    print(temp)
```
